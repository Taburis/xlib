"use strict";(self.webpackChunkxlib=self.webpackChunkxlib||[]).push([[8480],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),p=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,h=d["".concat(c,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(h,o(o({ref:t},s),{},{components:n})):a.createElement(h,o({ref:t},s))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2385:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return p},toc:function(){return s},default:function(){return d}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={},c="New Features in C++ Library",p={unversionedId:"Notes/C++/New_Features",id:"Notes/C++/New_Features",isDocsHomePage:!1,title:"New Features in C++ Library",description:"Rvalue",source:"@site/docs/Notes/C++/New_Features.md",sourceDirName:"Notes/C++",slug:"/Notes/C++/New_Features",permalink:"/xlib/Notes/C++/New_Features",editUrl:"https://github.com/Taburis/xlib/edit/documentation/docs/Notes/C++/New_Features.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Concurrency",permalink:"/xlib/Notes/C++/Concurrency"},next:{title:"Decision Trees",permalink:"/xlib/Notes/Machine Learning/Decision-Trees"}},s=[{value:"Rvalue",id:"rvalue",children:[{value:"Move Semantics",id:"move-semantics",children:[]},{value:"Perfect Forwarding",id:"perfect-forwarding",children:[]}]},{value:"Delete and Defaulted Functions",id:"delete-and-defaulted-functions",children:[]},{value:"Lambda Functions",id:"lambda-functions",children:[{value:"Capture local variables",id:"capture-local-variables",children:[]},{value:"Generic Lambdas and Generalized Captures",id:"generic-lambdas-and-generalized-captures",children:[]}]},{value:"Constexpr Functions",id:"constexpr-functions",children:[]}],u={toc:s};function d(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"new-features-in-c-library"},"New Features in C++ Library"),(0,i.kt)("h2",{id:"rvalue"},"Rvalue"),(0,i.kt)("hr",null),(0,i.kt)("p",null,"The lvalue and rvalue stands for the value can appear on the left and right side of assigment, respectively. The reference to lvalue and rvalue is"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int & lref;  // lvalue reference\nint && rref; // rvalue reference\nint const & ref; // const will convert the ref to the rvalue reference\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"std::move")," function is equivalent to the ",(0,i.kt)("inlineCode",{parentName:"p"},"static_cast<T&&>")," that will cast the object to a rvalue. The purpose for creating the rvalue conception is to solve at least the two problems:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Implementing the move semantics."),(0,i.kt)("li",{parentName:"ol"},"Perfect forwarding.")),(0,i.kt)("h3",{id:"move-semantics"},"Move Semantics"),(0,i.kt)("p",null,"A move semantics means that an object can be moved from one lvalue variable ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to another say ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),". It actually includes two steps, copy the object in ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),", and delete the object in ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),". But move semantics stands for a more efficient implementation that swaping the object held by ",(0,i.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"B"),", and then discard the object ",(0,i.kt)("inlineCode",{parentName:"p"},"A"),".  To implement the move semantics, a rvalue reference ",(0,i.kt)("inlineCode",{parentName:"p"},"obj&&")," is needed here to distinguish the lvalue assignment:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"obj& obj::operator = (obj && rhs){\n    //swap the values between this and rhs.\n}\n")),(0,i.kt)("p",null,"In this case, a lvalue input should trigger a normal copy assignment while the rvalue should trigger the move semantics. To ensure a move semantics for an object, the rvalue copy constructor and rvalue assignemnt operator should be defined:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"//classical copy and assignment constructor\nobj::obj(obj & rhs); \nobj & obj::operator = ( obj const &rhs); \n// this func can be call by both lvalue and rvalue, which is ambiguous\n//rvalue copy and assignment for move semantics\nobj::obj(obj && rhs);\n// This extra definition is needed to element the ambiguous for rvalue\nobj & obj::operator = ( obj && rhs); \n")),(0,i.kt)("p",null,"Then calling ",(0,i.kt)("inlineCode",{parentName:"p"},"obj x = std::move(y)")," will call the assignemnt with ",(0,i.kt)("inlineCode",{parentName:"p"},"std::move(y)")," as input first, and follow the copy constructor ",(0,i.kt)("inlineCode",{parentName:"p"},"obj(ojb &&)"),"."),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"It should be careful when we implement the rvalue assignemnt. Sometimes we don't delete the object in ",(0,i.kt)("inlineCode",{parentName:"p"},"lhs")," and it will just hold somewhere in the scope and be deleted after the scope closed. But the side effect brings from their destructor can be problematic. So the side effects should be cleared before we lost the access to it."))),(0,i.kt)("p",null,"A rvalue reference is a lvalue if it is held by a variable, otherwise, it is a rvalue:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"obj && c = obj();\n// c will be treated as a lvalue but obj() is a rvalue. \nobj x(c);\n// this will call the constructor obj(obj&) instead of obj(obj&&) for rvalue.\n")),(0,i.kt)("h3",{id:"perfect-forwarding"},"Perfect Forwarding"),(0,i.kt)("p",null,"For a template function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template <typename T>\nvoid func(T&& x);\n")),(0,i.kt)("p",null,"The actual type of reference is detemined by the following reference collapsing rules:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"T& &"),"  --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"T&")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"T&& &")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"T&")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"T& &&")," --\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"T&")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"T&& &&"),"--\x3e ",(0,i.kt)("inlineCode",{parentName:"li"},"T&&"))),(0,i.kt)("p",null,"For instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"func(obj&)")," means that ",(0,i.kt)("inlineCode",{parentName:"p"},"T=obj&")," so that if ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," is a lvalue reference, then it will be deducted into ",(0,i.kt)("inlineCode",{parentName:"p"},"obj &")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"func(x)"),".  This feature can be used in a perfect forwarding function ",(0,i.kt)("inlineCode",{parentName:"p"},"std::forward")," defined as"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template<class S>\nS&& forward(typename remove_reference<S>::type& a) noexcept\n{\n  return static_cast<S&&>(a);\n} \n")),(0,i.kt)("p",null,"will ",(0,i.kt)("inlineCode",{parentName:"p"},"noexcept")," tells the compiler that this function won't throw any exception. This forward function preserves the original value type for ",(0,i.kt)("inlineCode",{parentName:"p"},"arg")," when calling ",(0,i.kt)("inlineCode",{parentName:"p"},"std::forward<Arg>(arg)")," no matter if ",(0,i.kt)("inlineCode",{parentName:"p"},"arg")," is a lvalue or rvalue referred to the object ",(0,i.kt)("inlineCode",{parentName:"p"},"Arg"),"."),(0,i.kt)("h2",{id:"delete-and-defaulted-functions"},"Delete and Defaulted Functions"),(0,i.kt)("hr",null),(0,i.kt)("p",null,"For some cases, a perticular function is not allowed for an object. It can be specified by the key word ",(0,i.kt)("inlineCode",{parentName:"p"},"detele")," to prevent the compiler to pick it up.\nHere are two major usage:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Prevent the implicit constructor from compiler:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class obj{\n  public:\n    obj(){};\n    // removed the copy function to make the object non-copyable\n    obj(obj const & x) = delete;\n    obj& operator = (obj & x) = delete;\n};\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"To avoid implicit cast to restrict the input types:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// prevent the implicit convertion for int as inputs\nvoid func(short);\nvoid func(int) = delete;\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," is an opposite key word to the ",(0,i.kt)("inlineCode",{parentName:"p"},"delete"),". It tells the compiler to generate a function for you and this can only applied to constructor, desctructor and copy function that can be copied with ",(0,i.kt)("inlineCode",{parentName:"p"},"memcpy")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"memmove"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class X{\n  private:\n  // make the default generated function to be private\n    X() = default;\n  public:\n  // makes itake a non-const reference\n    X(X& ) = default ;\n    //declared for documentation\n    T& operator = (const X&) = default;\n  protected:\n    // change access and add virtual.\n    virtual ~X() = default;\n};\n")),(0,i.kt)("p",null,"A compiler generated constructor can be ",(0,i.kt)("strong",{parentName:"p"},"trivial")," which makes it can be used with ",(0,i.kt)("inlineCode",{parentName:"p"},"std::atomic<T>"),". "),(0,i.kt)("h2",{id:"lambda-functions"},"Lambda Functions"),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"C++11")," standard, the lambda expression is added to simply the code. The function defined by lambda expression looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// labmda function start with []\n[]{\n  // function body\n  do_something();\n  return value;\n}\n")),(0,i.kt)("p",null,"The input of a lambda function can be specified by adding ",(0,i.kt)("inlineCode",{parentName:"p"},"(inputs)")," follows the ",(0,i.kt)("inlineCode",{parentName:"p"},"[]"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"[](int a){return a+5;}\n")),(0,i.kt)("p",null,"It is requried to specify the return variable type if there's more than one return in lambda express:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"bool data_ready;\nstd::condition_variable cond;\n// specify the return type by using ->\ncond.wait(lk, []()->bool{\n  if(data_ready) return true;\n  else return false;\n})\n")),(0,i.kt)("h3",{id:"capture-local-variables"},"Capture local variables"),(0,i.kt)("p",null,"There are several way to capture local variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// [=] capture local variables by copy\nstd::function<int(int)> sum(int a, int b){\n  return [=](){return a+b;}\n}\n// [&] capture local variables by reference\nstd::function<int(int)> update(int a){\n  return [&](int x){\n    a =x; return a;}\n}\n")),(0,i.kt)("p",null,"The variables can also be captured mixing with copy and reference. For example ",(0,i.kt)("inlineCode",{parentName:"p"},"[=, &a, &b]")," will copy all the local variables except ",(0,i.kt)("inlineCode",{parentName:"p"},"a,b")," are captured by reference. Similar method works for ",(0,i.kt)("inlineCode",{parentName:"p"},"[&, a,b]")," can reference to all the variables except ",(0,i.kt)("inlineCode",{parentName:"p"},"a,b")," are copied."),(0,i.kt)("p",null,"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"this")," to capture the object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"stuct X{\n  int data;\n  void update(std::vector<int> &vec){\n    std::for_each(vec.begin(), vec.end(),\n    [this](int &j){i+=data;})\n  }\n}\n")),(0,i.kt)("h3",{id:"generic-lambdas-and-generalized-captures"},"Generic Lambdas and Generalized Captures"),(0,i.kt)("p",null,"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"C++14"),", the ",(0,i.kt)("strong",{parentName:"p"},"generic lambda")," can be formed by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," key word like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"auto f = [](auto x){std::cout<<x<<std::endl;};\n")),(0,i.kt)("p",null,"The type of the input to the function above will be deduced from the supplied argument when the lambda function is invoked."),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"generalized capture")," allows to capture the results of expressions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"std::future<int> spawn_async_task(){\n  std::promise<int> p;\n  auto f=p.get_future();\n  // here p is captured as the result of the std::move(p). \n  // this p has been moved into a thread, it is safe to detach the thread.\n  std::thread t([p=std::move(p)](){\n    p.set_value(find_the_anwer());\n  });\n  t.detach();\n  return f;\n}\n")),(0,i.kt)("h2",{id:"constexpr-functions"},"Constexpr Functions"),(0,i.kt)("hr",null),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"constexpr")," key word will convert the expression into constant expression, which are initiated statically. Since the constant expression is evaluated in compiled time insteand of runtime, it has unique flexibility."),(0,i.kt)("p",null,"A class is ",(0,i.kt)("strong",{parentName:"p"},"literal type")," if it satifies the following requirement:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"It's copy constructor is trivial."),(0,i.kt)("li",{parentName:"ol"},"The destructor is trivial."),(0,i.kt)("li",{parentName:"ol"},"All the non-static data members and base classes must be trivial types."),(0,i.kt)("li",{parentName:"ol"},"It must have a trivial constructor or a ",(0,i.kt)("inlineCode",{parentName:"li"},"constexpr")," constructor other than the copy constructor.")))}d.isMDXComponent=!0}}]);