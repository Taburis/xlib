"use strict";(self.webpackChunkxlib=self.webpackChunkxlib||[]).push([[2345],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),u=r,m=p["".concat(s,".").concat(u)]||p[u]||h[u]||o;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1648:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={},s="Concurrency",c={unversionedId:"Notes/C++/Concurrency",id:"Notes/C++/Concurrency",isDocsHomePage:!1,title:"Concurrency",description:"The purposes to program using concurrency are: dividing the concerns or functionality, and performance (parallelism). The latter is taking the advantages of multi-cores can handle multi-tasks at the same time. The former purpose is separating different functionalities required to run simultaneously into subprocess or thread.",source:"@site/docs/Notes/C++/Concurrency.md",sourceDirName:"Notes/C++",slug:"/Notes/C++/Concurrency",permalink:"/xlib/Notes/C++/Concurrency",editUrl:"https://github.com/Taburis/xlib/edit/master/docs/Notes/C++/Concurrency.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Tree Traversal",permalink:"/xlib/Notes/Algorithm/Tree-Traversal"},next:{title:"New Features in C++ Library",permalink:"/xlib/Notes/C++/New_Features"}},d=[{value:"Threads Management",id:"threads-management",children:[]},{value:"Sharing Data",id:"sharing-data",children:[{value:"Lockable Objects",id:"lockable-objects",children:[]},{value:"Block Multiple Locks",id:"block-multiple-locks",children:[]},{value:"Granularity of Lock",id:"granularity-of-lock",children:[]},{value:"Locking Order and Lock Hierarchy",id:"locking-order-and-lock-hierarchy",children:[]}]}],h={toc:d};function p(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"concurrency"},"Concurrency"),(0,o.kt)("p",null,"The purposes to program using concurrency are: dividing the concerns or functionality, and performance (parallelism). The latter is taking the advantages of multi-cores can handle multi-tasks at the same time. The former purpose is separating different functionalities required to run simultaneously into subprocess or thread. "),(0,o.kt)("p",null,"A process can have many threads which can sharing memories to each other. But communicate between processes is tricky as each process are protect by the system. Files or other ports may needed for the inter-process communication."),(0,o.kt)("p",null,"The approach to the concurrency can be classified into the following types:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Multi-processes: Dividing the functionality or programs into multiple, separate processes. Inter-communicating through the system operation."),(0,o.kt)("li",{parentName:"ol"},"Multi-threads: Implement the application in one process but using seveeral threads as light weighted processes. The threads communicate through the shared memories. (Supported since C++ 11)")),(0,o.kt)("h2",{id:"threads-management"},"Threads Management"),(0,o.kt)("hr",null),(0,o.kt)("p",null,"Launching a thread:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <thread>\nclass task; // the opeartor () is define for this object\nvoid work_to_do()\nvoid main(){\n    task x;\n    // passing the object x which x() is defined to a thread\n    std::thread t(x);\n    t.detach(); //let it run in the background\n    // passing the \n    std::thread my_thread(work_to_do)\n    my_thread.join(); // make the main wait my_thread to finish before close\n}\n")),(0,o.kt)("p",null,"Noticing that if passing the class to thread by using the default constructor is "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thead my_thread((task()));\n// or\nstd::thead my_thread{(task())};\n")),(0,o.kt)("p",null,"to prevent the confusion from defining a function named ",(0,o.kt)("inlineCode",{parentName:"p"},"my_thread")," with returning a thread and taking a function pointer with shape ",(0,o.kt)("inlineCode",{parentName:"p"},"f()")," as the input."),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"my_thread.join()")," to let the function to wait the finish of ",(0,o.kt)("inlineCode",{parentName:"p"},"my_thread")," before it move on. Each thread can only be joined once. A ",(0,o.kt)("inlineCode",{parentName:"p"},"thread_guard")," can be used to prevent the function closed before the thread finished:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class thread_guard\n{\n    std::thread &t;\n    public:\n        explicit thread_guard(std::thread &t_): t(t_) {}\n        ~thread_guard(){\n            if(t.joinable()){ t.join()}\n        }\n        // disable the default constructor to avoid the automate creation by the compiler\n        thread_guard(thread_guard const &) = delete; \n        // disable the assignment or copy to contrain the life scope for thread_guard\n        thread_guard & operator = (thread_guard const &) = delete;\n};\n// usage this guard\nvoid work(); // work needs to be run in parallel\nvoid f(){\n    std::thread t(work);\n    thread_guard g(t);\n    other_work_in_current_thread();\n}\n")),(0,o.kt)("p",null,"The destructor of ",(0,o.kt)("inlineCode",{parentName:"p"},"g")," will be called when the ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," reach to the end, it will join the thread ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," if it was still runing so that it won't be terminated due to the termination of ",(0,o.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"my_thread.detach()")," will let the thread run in the background. It will not joinable once it has been detached. "),(0,o.kt)("p",null,"Passing arguments to a thread can be done in the following types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'void f(std::string const &);\nvoid func(data &);\nvoid oops(){\n    char buffer[1024];\n    sprintf(buffer, "%i%", some_param);\n    // convert the char pointer into std::string explicity,\n    // otherwise the buffer will be converted to std::string in the detached thread.\n    // It has the risk that the function oops may finish before the buffer has been converted. \n    std::thread t(f, std::string(buffer));\n    t.detach();\n\n    data x;\n    //use std::ref to force it pass the reference instead of copy the object.\n    std::thread t2(f, std::ref(x));\n    t2.join();\n}\n')),(0,o.kt)("p",null,"The thread can be past as variables by using ",(0,o.kt)("inlineCode",{parentName:"p"},"std::move"),". It can be past into or out of a function. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thread t1 (some_work);\n// change the owner from t1 to t2\nstd::thread t2 = std::move(t1);\nt1 = std::thread( other_work);\n// if the thread hold by t2 was still running, it will be terminated.\nt2 = std::move(t1);\n")),(0,o.kt)("p",null,"To prevent the owner changing causes the confusing of the thread lifetime, a conception the scope thread can be implemented as"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'class scope_thread\n{\n    std::thread t;\n    public : \n        explicit scope_thread(std::thread t_): t(std::move(t_)){\n            if(!t.joinable()){\n                throw std::logic_error("No thread");\n            }\n        }\n        ~scope_thread(){\n            t.join();\n        }\n        //delete the copy and assignment to prevent the scope changing for scope_thread\n        scope_thread(scope_thread const &) = delete;\n        scope_thread & operator = (scope_thread const &) = delete;\n};\n// usage\nclass job;\nvoid f(){\n    scope_thread t{std::thread(job())};\n    the_rest_work_in_current_thread();\n}\n')),(0,o.kt)("p",null,"In this case, the thread is kept by the ",(0,o.kt)("inlineCode",{parentName:"p"},"scope_thread")," object and ensured to be finished before the scope is closed. This is important if the job may changing any variables in current scope, it will cause segmentation problem once the scope is closed but the thread is still trying to access these variables."),(0,o.kt)("p",null,"Each thread has a unique ",(0,o.kt)("inlineCode",{parentName:"p"},"std::thread::id")," can be obtained by ",(0,o.kt)("inlineCode",{parentName:"p"},"get_id()"),". The IDs can be compared but may not have any meaning as it may system depends. Only the equal of two IDs means that both threads are either the same or not exist. "),(0,o.kt)("h2",{id:"sharing-data"},"Sharing Data"),(0,o.kt)("hr",null),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"race condition")," is a case that multi-threads can access data in a undefined orders. It may reasults undefined behaviors. For instance, there is a data with a structure containing part A and B that correlated with each other. It is possible that one thread modified the part A while another thread modified the part B under a race condition. It may decorrelated the A and B which causes problem. A conception called ",(0,o.kt)("strong",{parentName:"p"},"invariant")," from the race condition is that the structure of the data is unchanged after an operation performed even in a race condition. For instance, a bi-directional list is still a bi-directional list after the thread modify the node under a race condition."),(0,o.kt)("p",null,"Several ideas can be used to avoid the problem in a race condition:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Lock: Using a lock to protect the data accessing by one thread from others."),(0,o.kt)("li",{parentName:"ol"},"Lock-free programming: Grouping the data together, make it invisible to other threads while one thread is accessing to it."),(0,o.kt)("li",{parentName:"ol"},"Transaction: Recording all data reading and modification opeartors from different threads in a transaction log. Updateing the data in one step. Restart the transaction if any conflicts happen.")),(0,o.kt)("p",null,"Besides of problematic race condition, a ",(0,o.kt)("strong",{parentName:"p"},"dead lock")," can also happen: Suppose two threads are locked and their next destiny is the data hold by each other. They will have to wait the other to release so to proceed. But this won't happen and caused the dead lock. The following methods can be used to safely share data between threads."),(0,o.kt)("h3",{id:"lockable-objects"},"Lockable Objects"),(0,o.kt)("p",null,"A value ",(0,o.kt)("inlineCode",{parentName:"p"},"m")," is a lockable type if the following functions are defined: ",(0,o.kt)("inlineCode",{parentName:"p"},"m.lock()"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"m.unlock()"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"m.try_lock()"),". "),(0,o.kt)("p",null,"Lockable objects provided by C++ STL ",(0,o.kt)("inlineCode",{parentName:"p"},"<mutex>")," header:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"std::mutex"),": A lock object provided ",(0,o.kt)("inlineCode",{parentName:"li"},"lock()"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"unlock()")," functions to hold and release the data accessing by the scoped function."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"std::shared_mutex"),": Similar as the ",(0,o.kt)("inlineCode",{parentName:"li"},"std::mutex"),", but can provide read-only accessibility for many threads with ",(0,o.kt)("inlineCode",{parentName:"li"},"std::shared_lock<std::shared_mutex>"),". It also can provide the exclusive accessibility with ",(0,o.kt)("inlineCode",{parentName:"li"},"std::lock_guard<std::shared_mutex>")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"std::unique_lock<std::shared_mutex>"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"std::recursive_mutex"),": Similar as the ",(0,o.kt)("inlineCode",{parentName:"li"},"std::mutex"),", but this one can call ",(0,o.kt)("inlineCode",{parentName:"li"},"lock()")," multiple times. But release the object will need the same times of calling ",(0,o.kt)("inlineCode",{parentName:"li"},"unlock()"),".  "),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"std::lock_guard<typename T>"),": A guard object can accept ",(0,o.kt)("inlineCode",{parentName:"li"},"std::mutex")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"std::shared_mutex")," to provide a exclusive accessibility. It unlocks the data when it is going to be destructed."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"std::unique_lock<typename T>"),": A object similar to the ",(0,o.kt)("inlineCode",{parentName:"li"},"std::lock_guard<typename T>")," with a unique semantics. It is moveable but not copyable. It can be used to transfer the mutex ownership between scopes."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"std::shared_lock<typename T>"),": A guard provides the read-only multi-accessibility with ",(0,o.kt)("inlineCode",{parentName:"li"},"std::shared_lock<std::shared_mutex>"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"std::lock(...)"),": A function can lock multi-mutex at once without deadlock risk.")),(0,o.kt)("p",null,"::: tip\nThe shared_mutex can be used to lock the data rarely be updated by using ",(0,o.kt)("inlineCode",{parentName:"p"},"std::shared_lock<std::shared_mutex>"),". This provides read-only multi-threads accessibility. It also can provides the exclusive accessibility when the data needs to be updated by using ",(0,o.kt)("inlineCode",{parentName:"p"},"std::unqiue_lock<std::shared_mutex>")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"std::lock_guard<std::shared_mutex>"),".\n:::"),(0,o.kt)("p",null,"Usage of the lockable object ",(0,o.kt)("inlineCode",{parentName:"p"},"mutex")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"std::lock_guard<std::mutex>")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"std::unqiue_lock<std::mutex>"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::list<int> data; // the data func will access to\nstd::mutex locker;\nvoid func(int value){\n    // locker guard will call the locker.lock() to preserve the data accessed by the func\n    // and will call locker.unlock() at the end of this function.\n    std::lock_guard<std::mutex> guard(locker);\n    // or  std::unique_lock<std::mutex> lk(locker);\n    data.push_back(value); // modify the data\n}\n")),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"scoped_lock")," guard is avaliable in C++17 compiler."),(0,o.kt)("div",{className:"admonition admonition-danger alert alert--danger"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"danger")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Don't pass pointer or reference to protected data outside the scope of the lock, wether by returning them from a function, storing them in externally visible memory, or passing them as arguments to user-supplied functions. Programs can still access the data by these pointers or references, which makes the lock nonsense. "))),(0,o.kt)("p",null,"The ownership of the ",(0,o.kt)("inlineCode",{parentName:"p"},"std::unique_lock")," can be transferred due to the unique semantics (move semantics but not copyable). The function own the lock can access the data blocked by the lock:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::unique_lock<std::mutex> get_lock(){\n    extern std::mutex m; // due to the mutex is neither copyable nor movable.\n    std::unique_lock<std::mutex> lk(m);\n    prepare_data();\n    return lk; \n}\nvoid process_data(){\n    std::unique_lock<std::mutex> lk(get_lock());\n    do_something_with_data();\n}\n")),(0,o.kt)("p",null,"Here the ",(0,o.kt)("inlineCode",{parentName:"p"},"unqiue_lock")," serves like a gateway to access the data."),(0,o.kt)("h3",{id:"block-multiple-locks"},"Block Multiple Locks"),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"std::lock()")," to lock multiple ",(0,o.kt)("inlineCode",{parentName:"p"},"mutex")," can avoid deadlock. The ",(0,o.kt)("inlineCode",{parentName:"p"},"std::lock()")," locks one ",(0,o.kt)("inlineCode",{parentName:"p"},"mutex")," and try to lock another ",(0,o.kt)("inlineCode",{parentName:"p"},"mutex"),". An exception will throw if it failed and the held ",(0,o.kt)("inlineCode",{parentName:"p"},"mutex")," will be released. Here is an example to implement a ",(0,o.kt)("inlineCode",{parentName:"p"},"swap")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class X{\n    private:\n        std::mutex m;\n        data_type data;\n    public:\n        X(data_type &d): data(d){}\n        friend void swap(X& lhs, X& rhs){\n            if(&lhs==&rhs) return;\n            std::lock(lhs.m, rhs.m);\n            // using std::adopt_lock flag indicates that the mutex is already locked.\n            std::lock_guard<std::mutex> lock_a(lhs.m, std::adopt_lock);\n            std::lock_guard<std::mutex> lock_b(rhs.m, std::adopt_lock);\n            swap(lhs.data, rhs.data);\n        }\n        // using the unique_lock to implement the swap is a little bit different\n        friend void swap(X& lhs, X& rhs){\n            if(&lhs==&rhs) return;\n            // std::defer_lock will let the mutex remain unlocked.\n            std::unique_lock<std::mutex> lock_a (lhs.m, std::defer_lock);\n            std::unique_lock<std::mutex> lock_b (rhs.m, std::defer_lock);\n            std::lock(lock_a, lock_b);\n            swap(lhs.data, rhs.data);\n        }\n}\n")),(0,o.kt)("h3",{id:"granularity-of-lock"},"Granularity of Lock"),(0,o.kt)("p",null,"Locking the function can be subtle. The problem can happen if locking the function in a very fine granularity. The race condition can happen in between calling functions and here is few problems can happen in a ",(0,o.kt)("inlineCode",{parentName:"p"},"stack")," object: "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Race in status check: Although ",(0,o.kt)("inlineCode",{parentName:"li"},"mutex")," can protect the data during accessing, the race condition can also cause problem. For instance, a ",(0,o.kt)("inlineCode",{parentName:"li"},"std::stack::empty()")," may return ",(0,o.kt)("inlineCode",{parentName:"li"},"false"),", and other thread follows imediately popped one elements that empty the stack. Since the ",(0,o.kt)("inlineCode",{parentName:"li"},"empty()")," query happened and mutex unlocked the stack, so the pop can be performed. The same reason can cause problem for functions like ",(0,o.kt)("inlineCode",{parentName:"li"},"size()"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"empty()"),", et al."),(0,o.kt)("li",{parentName:"ul"},"Race causes the copy unsafe: ",(0,o.kt)("inlineCode",{parentName:"li"},"pop()")," function will copy the object to the target and delete the top element in stack. However, if the copy happens after the deletion, it may cause problem that the element has been removed but the copy failed. For this problem, there is several solutions:")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Pass in reference: create a variable to contain the value first, then pass the reference to the variable")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<int> data;\nstack.pop(data);\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Move constructor: If the data popped out has a move constructor or a constructor don't throw exception. Using them during pop(). This is because the exception is the only problem interupt the ",(0,o.kt)("inlineCode",{parentName:"li"},"pop()")," in the middle."),(0,o.kt)("li",{parentName:"ol"},"A pointer to the item: The pointer can be copied without throwing an exception. To simplify the memory management, one can use the ",(0,o.kt)("inlineCode",{parentName:"li"},"std::shared_ptr")," as the object will be delete automatically if the last pointer to the object is delete. So the basic solution is to ",(0,o.kt)("strong",{parentName:"li"},"adjust the granlarity of lock on data"),". Many of the problems above can be classified a too small lock granularity. But the trade off increasing the granularity can be the concurrency performance degeneration. ")),(0,o.kt)("p",null,"Here is a example of thread safe stack"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <exception>\n#include <memory>\n#include <mutex>\n#include <stack>\n\n// define a exception of the empty stack\nstruct empty_stack: std::exception{\n    const char * what() const throw();\n};\ntemplate <typename T>\nclass threadsafe_stack{\n    private:\n        std::stack<T> data;\n        mutable std::mutex m;\n    public:\n        threadsafe_stack(){}\n        threadsafe_stack(const threadsafe_stack & other){\n            std::lock_guard<std::mutex> lock(other.m);\n            data = other.data;\n        }\n        //make the stack uncopiable to increase the safety.\n        threadsafe_stack & operator = (const threadsafe_stack &) = delete;\n        void push(T value){\n            std::lock_guard<std::mutex> lock(m);\n            data.push(std::move(value));\n        }\n        std::shared_ptr<T> pop(){\n            std::lock_guard<std::mutex> lock(m);\n            //checking if the stack is empty to avoid pop on 0 size stack\n            if(data.empty()) throw empty_stack();\n            // return the pointer to prevent the throw during copy\n            std::shared_ptr<T> const res (std::make_shared<T>(data.top()));\n            data.pop();\n            return res;\n        }\n        // provide other method for fexibility\n        void pop(T& value){\n            std::lock_guard<std::mutex> lock(m);\n            //checking if the stack is empty to avoid pop on 0 size stack\n            if(data.empty()) throw empty_stack();\n            value = data.top();\n            data.pop();\n        }\n        // this empty function might be redundant in this threadsafe stack\n        bool empty() const {\n            std::lock_guard<std::mutex> lock(m);\n            return data.empty();\n        }\n};\n")),(0,o.kt)("p",null,"On the other side, locking functions in too coarsely will slow down the performance. If copy the data is cheap, unlock the function after copy the data can be a good idea. One example is an object concurrent safe but is expensive to initialization. It is important to secure the initialization to avoid multi-threads creation at the same time:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::shared_ptr<some_resource> resource_ptr;\nstd::mutex m;\nvoid foo(){\n    std::unique_lock<std::mutex> lk(m);\n    if(! resource_ptr){\n        resource_ptr.reset(new some_resource);\n    }\n    lk.unlokc();\n    resource_ptr->do_something();\n}\n")),(0,o.kt)("p",null,"The code above presents the logic but it has potential problematic racing: The race can happen after checked the ",(0,o.kt)("inlineCode",{parentName:"p"},"if")," statement. One double-checked locking is still not perfect solution. A ",(0,o.kt)("inlineCode",{parentName:"p"},"std::call_once")," can be used to solve this problem:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class X{\n    private:\n        data_format data;\n        std::once_flag init_flag;\n        void init(){ data = create_data();} // func to initialize the data\n    public :\n        X(){}\n        void call(){\n            std::call_once(init_flag, &X::init, this);\n            do_something(data);\n        }\n}\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"std::call_once(std::once_flag, Callable&& f, Args && ...)")," will call the function ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," with the arguments ",(0,o.kt)("inlineCode",{parentName:"p"},"arg")," is the ",(0,o.kt)("inlineCode",{parentName:"p"},"once_flag")," indicate no call previously. ",(0,o.kt)("inlineCode",{parentName:"p"},"std::once_flag")," can't be copy or move.  "),(0,o.kt)("h3",{id:"locking-order-and-lock-hierarchy"},"Locking Order and Lock Hierarchy"),(0,o.kt)("p",null,"One of the most efficient way to prevent dead lock is to fix the order of locking and unlocking. A concept of hierarchy lock is a lock assigned a hierachy so that a lock can only happen if the lock hierachy is lower than the current hierachy held. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"hierachical_mutex high_level_m(1000), low_level_m(500), other_level_m(600);\nint do_low_level_stuff();\nint low_level_func(){\n    // the function be called by other functions should have lower hierarchy;\n    std::lock_guard<hierarchical_mutex> lk(low_level_m);\n    return do_low_level_stuff();\n}\nint high_level_func(){\n    // the high hierarchcial lock used for high level function;\n    std::lock_guard<hierarchical_mutex> lk(high_level_m);\n    do_high_level_stuff(low_level_func());\n}\n")),(0,o.kt)("p",null,"In this way, the order of locks are defined by the function levels. Any case calling a high level locks in lower level function should throw an exception in run time, and hence will not be able to cause a dead lock. The implementation of the hierachical lock is not part of STL but easy to make:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'class hierarchical_mutex{\n    std::mutex internal_mutex;\n    // assign the hierachy value for each hierarchical mutex\n    unsigned long const hierarchy_value;\n    // track the previous thread hierarchy value, it needs to be stored\n    // if the current mutex is unlocked.\n    unsigned long previous_hierarchy_value;\n    //a thread-global variable to keep the hierarchy value of current mutex\n    static thread_local unsigned long this_thread_herarchy_value;\n    void check_for_herarchy_violation(){\n        if(this_thread_hierarch_value <= hierarchy_value)\n            throw std::logic_error("mutex hierarchy violated");\n    }\n    void update_hierachy_value(){\n        previous_hierarchy_value = this_thread_hierarchy_value;\n        this_thread_hierarchy_value = hierarchy_value;\n    }\n    public: \n        explicit hierarchical_mutex (unsigend long value):\n            hierarchy_value (value),\n            previous_hierarchy_value(0){}\n        void lock(){\n            check_for_hierarchy_violation();\n            internal_mutex.lock();\n            update_hierarchy_value();\n        }\n        void unlock(){\n            //by the definition, if the current hierarchy value isn\'t the hierarchy\n            //value of this mutex, the current thread is locked by other mutex so \n            //unlock this mutex will mess up the lock hierarchy.\n            if(this_hierarchy_value != hierarchy_value)\n                throw std::logic_error("mutex hierarchy violated");\n            this_thread_hierarchy_value= previous_hierarchy_value;\n            internal_mutex.unlock();\n        }\n        bool try_lock(){\n            check_for_hierarchy_violation();\n            if(!internal_mutex.try_lock()) return false;\n            update_hierarchy_value();\n            return true;\n        }\n};\n//init the current thread hierarchy with the maximum value to allow any hierachy lock\n// is allowed at the begining of the thread. \nthread_local unsigned long \n    hierarchical_mutex::this_thread_hierarchy_value(ULONG_MAX);\n')))}p.isMDXComponent=!0}}]);