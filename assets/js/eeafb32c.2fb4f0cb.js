"use strict";(self.webpackChunkxlib=self.webpackChunkxlib||[]).push([[2345],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return u}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),d=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=d(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),h=d(n),u=r,m=h["".concat(c,".").concat(u)]||h[u]||p[u]||o;return n?a.createElement(m,i(i({ref:t},l),{},{components:n})):a.createElement(m,i({ref:t},l))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1648:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return l},default:function(){return h}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={},c="Concurrency",d={unversionedId:"Notes/C++/Concurrency",id:"Notes/C++/Concurrency",isDocsHomePage:!1,title:"Concurrency",description:"The purposes to program using concurrency are: dividing the concerns or functionality, and performance (parallelism). The latter is taking the advantages of multi-cores can handle multi-tasks at the same time. The former purpose is separating different functionalities required to run simultaneously into subprocess or thread.",source:"@site/docs/Notes/C++/Concurrency.md",sourceDirName:"Notes/C++",slug:"/Notes/C++/Concurrency",permalink:"/xlib/Notes/C++/Concurrency",editUrl:"https://github.com/Taburis/xlib/edit/master/docs/Notes/C++/Concurrency.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Tree",permalink:"/xlib/Notes/Algorithm/Tree"},next:{title:"Decision Trees",permalink:"/xlib/Notes/Machine Learning/Decision-Trees"}},l=[{value:"Threads Management",id:"threads-management",children:[]},{value:"Sharing Data",id:"sharing-data",children:[]}],p={toc:l};function h(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"concurrency"},"Concurrency"),(0,o.kt)("p",null,"The purposes to program using concurrency are: dividing the concerns or functionality, and performance (parallelism). The latter is taking the advantages of multi-cores can handle multi-tasks at the same time. The former purpose is separating different functionalities required to run simultaneously into subprocess or thread. "),(0,o.kt)("p",null,"A process can have many threads which can sharing memories to each other. But communicate between processes is tricky as each process are protect by the system. Files or other ports may needed for the inter-process communication."),(0,o.kt)("p",null,"The approach to the concurrency can be classified into the following types:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Multi-processes: Dividing the functionality or programs into multiple, separate processes. Inter-communicating through the system operation."),(0,o.kt)("li",{parentName:"ol"},"Multi-threads: Implement the application in one process but using seveeral threads as light weighted processes. The threads communicate through the shared memories. (Supported since C++ 11)")),(0,o.kt)("h2",{id:"threads-management"},"Threads Management"),(0,o.kt)("p",null,"Launching a thread:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <thread>\nclass task; // the opeartor () is define for this object\nvoid work_to_do()\nvoid main(){\n    task x;\n    // passing the object x which x() is defined to a thread\n    std::thread t(x);\n    t.detach(); //let it run in the background\n    // passing the \n    std::thread my_thread(work_to_do)\n    my_thread.join(); // make the main wait my_thread to finish before close\n}\n")),(0,o.kt)("p",null,"Noticing that if passing the class to thread by using the default constructor is "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thead my_thread((task()));\n// or\nstd::thead my_thread{(task())};\n")),(0,o.kt)("p",null,"to prevent the confusion from defining a function named ",(0,o.kt)("inlineCode",{parentName:"p"},"my_thread")," with returning a thread and taking a function pointer with shape ",(0,o.kt)("inlineCode",{parentName:"p"},"f()")," as the input."),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"my_thread.join()")," to let the function to wait the finish of ",(0,o.kt)("inlineCode",{parentName:"p"},"my_thread")," before it move on. Each thread can only be joined once. A ",(0,o.kt)("inlineCode",{parentName:"p"},"thread_guard")," can be used to prevent the function closed before the thread finished:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class thread_guard\n{\n    std::thread &t;\n    public:\n        explicit thread_guard(std::thread &t_): t(t_) {}\n        ~thread_guard(){\n            if(t.joinable()){ t.join()}\n        }\n        // disable the default constructor to avoid the automate creation by the compiler\n        thread_guard(thread_guard const &) = delete; \n        // disable the assignment or copy to contrain the life scope for thread_guard\n        thread_guard & operator = (thread_guard const &) = delete;\n};\n// usage this guard\nvoid work(); // work needs to be run in parallel\nvoid f(){\n    std::thread t(work);\n    thread_guard g(t);\n    other_work_in_current_thread();\n}\n")),(0,o.kt)("p",null,"The destructor of ",(0,o.kt)("inlineCode",{parentName:"p"},"g")," will be called when the ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," reach to the end, it will join the thread ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," if it was still runing so that it won't be terminated due to the termination of ",(0,o.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"my_thread.detach()")," will let the thread run in the background. It will not joinable once it has been detached. "),(0,o.kt)("p",null,"Passing arguments to a thread can be done in the following types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'void f(std::string const &);\nvoid func(data &);\nvoid oops(){\n    char buffer[1024];\n    sprintf(buffer, "%i%", some_param);\n    // convert the char pointer into std::string explicity,\n    // otherwise the buffer will be converted to std::string in the detached thread.\n    // It has the risk that the function oops may finish before the buffer has been converted. \n    std::thread t(f, std::string(buffer));\n    t.detach();\n\n    data x;\n    //use std::ref to force it pass the reference instead of copy the object.\n    std::thread t2(f, std::ref(x));\n    t2.join();\n}\n')),(0,o.kt)("p",null,"The thread can be past as variables by using ",(0,o.kt)("inlineCode",{parentName:"p"},"std::move"),". It can be past into or out of a function. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thread t1 (some_work);\n// change the owner from t1 to t2\nstd::thread t2 = std::move(t1);\nt1 = std::thread( other_work);\n// if the thread hold by t2 was still running, it will be terminated.\nt2 = std::move(t1);\n")),(0,o.kt)("p",null,"To prevent the owner changing causes the confusing of the thread lifetime, a conception the scope thread can be implemented as"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'class scope_thread\n{\n    std::thread t;\n    public : \n        explicit scope_thread(std::thread t_): t(std::move(t_)){\n            if(!t.joinable()){\n                throw std::logic_error("No thread");\n            }\n        }\n        ~scope_thread(){\n            t.join();\n        }\n        //delete the copy and assignment to prevent the scope changing for scope_thread\n        scope_thread(scope_thread const &) = delete;\n        scope_thread & operator = (scope_thread const &) = delete;\n};\n// usage\nclass job;\nvoid f(){\n    scope_thread t{std::thread(job())};\n    the_rest_work_in_current_thread();\n}\n')),(0,o.kt)("p",null,"In this case, the thread is kept by the ",(0,o.kt)("inlineCode",{parentName:"p"},"scope_thread")," object and ensured to be finished before the scope is closed. This is important if the job may changing any variables in current scope, it will cause segmentation problem once the scope is closed but the thread is still trying to access these variables."),(0,o.kt)("p",null,"Each thread has a unique ",(0,o.kt)("inlineCode",{parentName:"p"},"std::thread::id")," can be obtained by ",(0,o.kt)("inlineCode",{parentName:"p"},"get_id()"),". The IDs can be compared but may not have any meaning as it may system depends. Only the equal of two IDs means that both threads are either the same or not exist. "),(0,o.kt)("h2",{id:"sharing-data"},"Sharing Data"),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"race condition")," is a case that multi-threads can access data in a undefined orders. It may reasults undefined behaviors. For instance, there is a data with a structure containing part A and B that correlated with each other. It is possible that one thread modified the part A while another thread modified the part B under a race condition. It may decorrelated the A and B which causes problem. A conception called ",(0,o.kt)("strong",{parentName:"p"},"invariant")," from the race condition is that the structure of the data is unchanged after an operation performed even in a race condition. For instance, a bi-directional list is still a bi-directional list after the thread modify the node under a race condition."),(0,o.kt)("p",null,"Several ideas can be used to avoid the problem in a race condition:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Lock-free programming: Grouping the data together, make it invisible to other threads while one thread is accessing to it."),(0,o.kt)("li",{parentName:"ol"},"Transaction: Recording all data reading and modification opeartors from different threads in a transaction log. Updateing the data in one step. Restart the transaction if any conflicts happen.")),(0,o.kt)("p",null,"Locking the data accessed by a function ",(0,o.kt)("inlineCode",{parentName:"p"},"func")," using ",(0,o.kt)("inlineCode",{parentName:"p"},"mutex"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::list<int> data; // the data func will access to\nstd::mutex locker;\nvoid func(int value){\n    // locker guard will call the locker.lock() to preserve the data accessed by the func\n    // and will call locker.unlock() at the end of this function.\n    std::lock_guard<std::mutex> guard(locker);\n    data.push_back(value); // modify the data\n}\n")),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"scoped_lock")," guard is avaliable in C++17 compiler."),(0,o.kt)("div",{className:"admonition admonition-danger alert alert--danger"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"danger")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Don't pass pointer or reference to protected data outside the scope of the lock, wether by returning them from a function, storing them in externally visible memory, or passing them as arguments to user-supplied functions. Programs can still access the data by these pointers or references, which makes the lock nonsense. "))),(0,o.kt)("p",null,"The race condition may also leads to the following problems:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Race in status check: Although ",(0,o.kt)("inlineCode",{parentName:"li"},"mutex")," can protect the data during accessing, the race condition can also cause problem. For instance, a ",(0,o.kt)("inlineCode",{parentName:"li"},"std::stack::empty()")," may return ",(0,o.kt)("inlineCode",{parentName:"li"},"false"),", and other thread follows imediately popped one elements that empty the stack. Since the ",(0,o.kt)("inlineCode",{parentName:"li"},"empty()")," query happened and mutex unlocked the stack, so the pop can be performed. The same reason can cause problem for functions like ",(0,o.kt)("inlineCode",{parentName:"li"},"size()"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"empty()"),", et al."),(0,o.kt)("li",{parentName:"ul"},"Race causes the copy unsafe: ",(0,o.kt)("inlineCode",{parentName:"li"},"pop()")," function will copy the object to the target and delete the top element in stack. However, if the copy happens after the deletion, it may cause problem that the element has been removed but the copy failed. For this problem, there is several solutions:")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Pass in reference: create a variable to contain the value first, then pass the reference to the variable")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<int> data;\nstack.pop(data);\n")),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},"Move constructor: If the data popped out has a move constructor or a constructor don't throw exception. Using them during pop(). This is because the exception is the only problem interupt the ",(0,o.kt)("inlineCode",{parentName:"li"},"pop()")," in the middle."),(0,o.kt)("li",{parentName:"ol"},"A pointer to the item: The pointer can be copied without throwing an exception. To simplify the memory management, one can use the ",(0,o.kt)("inlineCode",{parentName:"li"},"std::shared_ptr")," as the object will be delete automatically if the last pointer to the object is delete.")),(0,o.kt)("p",null,"Here is a example of thread safe stack"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <exception>\n#include <memory>\n#include <mutex>\n#include <stack>\n\n// define a exception of the empty stack\nstruct empty_stack: std::exception{\n    const char * what() const throw();\n};\ntemplate <typename T>\nclass threadsafe_stack{\n    private:\n        std::stack<T> data;\n        mutable std::mutex m;\n    public:\n        threadsafe_stack(){}\n        threadsafe_stack(const threadsafe_stack & other){\n            std::lock_guard<std::mutex> lock(other.m);\n            data = other.data;\n        }\n        //make the stack uncopiable to increase the safety.\n        threadsafe_stack & operator = (const threadsafe_stack &) = delete;\n        void push(T value){\n            std::lock_guard<std::mutex> lock(m);\n            data.push(std::move(value));\n        }\n        std::shared_ptr<T> pop(){\n            std::lock_guard<std::mutex> lock(m);\n            //checking if the stack is empty to avoid pop on 0 size stack\n            if(data.empty()) throw empty_stack();\n            // return the pointer to prevent the throw during copy\n            std::shared_ptr<T> const res (std::make_shared<T>(data.top()));\n            data.pop();\n            return res;\n        }\n        // provide other method for fexibility\n        void pop(T& value){\n            std::lock_guard<std::mutex> lock(m);\n            //checking if the stack is empty to avoid pop on 0 size stack\n            if(data.empty()) throw empty_stack();\n            value = data.top();\n            data.pop();\n        }\n};\n")))}h.isMDXComponent=!0}}]);