"use strict";(self.webpackChunkxlib=self.webpackChunkxlib||[]).push([[2345],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return u}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),d=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=d(e.components);return r.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,m=p["".concat(c,".").concat(u)]||p[u]||h[u]||o;return n?r.createElement(m,i(i({ref:t},l),{},{components:n})):r.createElement(m,i({ref:t},l))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1648:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return l},default:function(){return p}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),i=["components"],s={},c="Concurrency",d={unversionedId:"Notes/C++/Concurrency",id:"Notes/C++/Concurrency",isDocsHomePage:!1,title:"Concurrency",description:"The purposes to program using concurrency are: dividing the concerns or functionality, and performance (parallelism). The latter is taking the advantages of multi-cores can handle multi-tasks at the same time. The former purpose is separating different functionalities required to run simultaneously into subprocess or thread.",source:"@site/docs/Notes/C++/Concurrency.md",sourceDirName:"Notes/C++",slug:"/Notes/C++/Concurrency",permalink:"/xlib/Notes/C++/Concurrency",editUrl:"https://github.com/Taburis/xlib/edit/master/docs/Notes/C++/Concurrency.md",version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Tree",permalink:"/xlib/Notes/Algorithm/Tree"},next:{title:"Decision Trees",permalink:"/xlib/Notes/Machine Learning/Decision-Trees"}},l=[{value:"Threads Management",id:"threads-management",children:[]},{value:"Sharing Data",id:"sharing-data",children:[]}],h={toc:l};function p(e){var t=e.components,n=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"concurrency"},"Concurrency"),(0,o.kt)("p",null,"The purposes to program using concurrency are: dividing the concerns or functionality, and performance (parallelism). The latter is taking the advantages of multi-cores can handle multi-tasks at the same time. The former purpose is separating different functionalities required to run simultaneously into subprocess or thread. "),(0,o.kt)("p",null,"A process can have many threads which can sharing memories to each other. But communicate between processes is tricky as each process are protect by the system. Files or other ports may needed for the inter-process communication."),(0,o.kt)("p",null,"The approach to the concurrency can be classified into the following types:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Multi-processes: Dividing the functionality or programs into multiple, separate processes. Inter-communicating through the system operation."),(0,o.kt)("li",{parentName:"ol"},"Multi-threads: Implement the application in one process but using seveeral threads as light weighted processes. The threads communicate through the shared memories. (Supported since C++ 11)")),(0,o.kt)("h2",{id:"threads-management"},"Threads Management"),(0,o.kt)("p",null,"Launching a thread:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <thread>\nclass task; // the opeartor () is define for this object\nvoid work_to_do()\nvoid main(){\n    task x;\n    // passing the object x which x() is defined to a thread\n    std::thread t(x);\n    t.detach(); //let it run in the background\n    // passing the \n    std::thread my_thread(work_to_do)\n    my_thread.join(); // make the main wait my_thread to finish before close\n}\n")),(0,o.kt)("p",null,"Noticing that if passing the class to thread by using the default constructor is "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thead my_thread((task()));\n// or\nstd::thead my_thread{(task())};\n")),(0,o.kt)("p",null,"to prevent the confusion from defining a function named ",(0,o.kt)("inlineCode",{parentName:"p"},"my_thread")," with returning a thread and taking a function pointer with shape ",(0,o.kt)("inlineCode",{parentName:"p"},"f()")," as the input."),(0,o.kt)("p",null,"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"my_thread.join()")," to let the function to wait the finish of ",(0,o.kt)("inlineCode",{parentName:"p"},"my_thread")," before it move on. Each thread can only be joined once. A ",(0,o.kt)("inlineCode",{parentName:"p"},"thread_guard")," can be used to prevent the function closed before the thread finished:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class thread_guard\n{\n    std::thread &t;\n    public:\n        explicit thread_guard(std::thread &t_): t(t_) {}\n        ~thread_guard(){\n            if(t.joinable()){ t.join()}\n        }\n        // disable the default constructor to avoid the automate creation by the compiler\n        thread_guard(thread_guard const &) = delete; \n        // disable the assignment or copy to contrain the life scope for thread_guard\n        thread_guard & operator = (thread_guard const &) = delete;\n};\n// usage this guard\nvoid work(); // work needs to be run in parallel\nvoid f(){\n    std::thread t(work);\n    thread_guard g(t);\n    other_work_in_current_thread();\n}\n")),(0,o.kt)("p",null,"The destructor of ",(0,o.kt)("inlineCode",{parentName:"p"},"g")," will be called when the ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," reach to the end, it will join the thread ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," if it was still runing so that it won't be terminated due to the termination of ",(0,o.kt)("inlineCode",{parentName:"p"},"f"),"."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"my_thread.detach()")," will let the thread run in the background. It will not joinable once it has been detached. "),(0,o.kt)("p",null,"Passing arguments to a thread can be done in the following types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'void f(std::string const &);\nvoid func(data &);\nvoid oops(){\n    char buffer[1024];\n    sprintf(buffer, "%i%", some_param);\n    // convert the char pointer into std::string explicity,\n    // otherwise the buffer will be converted to std::string in the detached thread.\n    // It has the risk that the function oops may finish before the buffer has been converted. \n    std::thread t(f, std::string(buffer));\n    t.detach();\n\n    data x;\n    //use std::ref to force it pass the reference instead of copy the object.\n    std::thread t2(f, std::ref(x));\n    t2.join();\n}\n')),(0,o.kt)("p",null,"The thread can be past as variables by using ",(0,o.kt)("inlineCode",{parentName:"p"},"std::move"),". It can be past into or out of a function. "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"std::thread t1 (some_work);\n// change the owner from t1 to t2\nstd::thread t2 = std::move(t1);\nt1 = std::thread( other_work);\n// if the thread hold by t2 was still running, it will be terminated.\nt2 = std::move(t1);\n")),(0,o.kt)("p",null,"To prevent the owner changing causes the confusing of the thread lifetime, a conception the scope thread can be implemented as"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'class scope_thread\n{\n    std::thread t;\n    public : \n        explicit scope_thread(std::thread t_): t(std::move(t_)){\n            if(!t.joinable()){\n                throw std::logic_error("No thread");\n            }\n        }\n        ~scope_thread(){\n            t.join();\n        }\n        //delete the copy and assignment to prevent the scope changing for scope_thread\n        scope_thread(scope_thread const &) = delete;\n        scope_thread & operator = (scope_thread const &) = delete;\n};\n// usage\nclass job;\nvoid f(){\n    scope_thread t{std::thread(job())};\n    the_rest_work_in_current_thread();\n}\n')),(0,o.kt)("p",null,"In this case, the thread is kept by the ",(0,o.kt)("inlineCode",{parentName:"p"},"scope_thread")," object and ensured to be finished before the scope is closed. This is important if the job may changing any variables in current scope, it will cause segmentation problem once the scope is closed but the thread is still trying to access these variables."),(0,o.kt)("p",null,"Each thread has a unique ",(0,o.kt)("inlineCode",{parentName:"p"},"std::thread::id")," can be obtained by ",(0,o.kt)("inlineCode",{parentName:"p"},"get_id()"),". The IDs can be compared but may not have any meaning as it may system depends. Only the equal of two IDs means that both threads are either the same or not exist. "),(0,o.kt)("h2",{id:"sharing-data"},"Sharing Data"))}p.isMDXComponent=!0}}]);